---
date: 2024-12-27
title: 04 Typescipt
---
- Status: Draft  
- Deciders: Serggio Pizzella, Luuk Horsman  
- Informed: Erik Schriek

---

## Context and Problem Statement
When this project began, we naturally gravitated toward using C# for the language server, as Info Support is a .NET-focused company, and the internal mentors expertise lay primarily in C#. This choice seemed logical.

Shortly after development began, however, we encountered several unforeseen obstacles. These ranged from the lack of current documentation for critical libraries, to difficulties ensuring robust YAML parsing, to the challenges of finding a mature library for the Language Server Protocol (LSP). We tried to work around these constraints, but each setback eroded the efficiency required to complete the project.

Furthermore, Microsoft’s own LSP specification is heavily oriented toward the TypeScript ecosystem. Our sense was that, despite the strong foundation of .NET in the company, a switch to TypeScript could remove many of these roadblocks. This decision, was not taken lightly. Below, we detail the specific issues we faced, and the reasons TypeScript emerged as a strong alternative.

---

## Considered Options
When researching alternatives, our guiding question was: “Which ecosystems already have robust implementations for the Language Server Protocol (LSP)?” One way to gauge this is by looking at [Microsoft’s own list of LSP implementations](https://microsoft.github.io/language-server-protocol/implementors/servers/).This list isn’t fully exhaustive, but it’s a reasonable indicator of where active development is happening. The data we gathered revealed that **TypeScript** is by far the most common language among LSP implementations, which aligns with the fact that Microsoft developed the LSP specification and libraries, primarily for use in Visual Studio Code (written in TypeScript).

In total, we found entries for **54** different languages, the majority of which appear only once. To keep this comparison manageable, we only included languages with **five** or more implementations in our final chart:
![[Servers per Language.svg]]

From these findings, we saw that **TypeScript** is the clear leader with **72** servers, distantly followed by **Rust** at **33**, while **C#**, **C++**, and **Go** tie at **15**. Rust presented a good amount of implementations, and is well known for performance and documentation, however due to the complexity of the language and lack of expertise, it was immediately discarded as an option.

## Decision Drivers

The primary drivers that influenced our decision came from three main categories:

1. **Tree-sitter Integration**  
    While we believed the C# Tree-sitter bindings would be robust. This given that C# is listed as an officially supported language, however closer inspection told a different story. The available repository was outdated, with no meaningful documentation and minimal community activity. By contrast, the TypeScript/JavaScript version of Tree-sitter is actively maintained, includes setup instructions, and offers minimal but sufficient documentation.
	Additionally, the default project generated by the Tree-sitter CLI, generates a `package.json` that makes it trivial to publish and use.

2. **YAML Parsing Capabilities**  
	In .NET, we struggled to find a fully supported, well-documented YAML parser. The most recognized option, YamlDotNet, had sparse documentation on advanced features like custom deserialization and error handling. Without clear references or guidance, any robust parsing solution would require significant reverse-engineering and risk hidden error flows. On the other hand, in the TypeScript ecosystem, libraries like `eemily/yaml` provide excellent documentation, highlight resilience guarantees (especially around error handling), and are updated regularly.

1. **Maturity of LSP Libraries**  
	One of the most pressing needs for our project was a library that could handle LSP diagnostics reliably. While .NET offers OmniSharp's library, an seemingly good toolkit, its diagnostics feature was missing or partially implemented, leaving us with open GitHub issues and no clear path to resolution. In contrast, the official LSP implementation from Microsoft is geared toward a TypeScript/Node.js environment, which includes well-documented, actively maintained libraries and sample implementations for key features like auto completion.

Additionally, Microsoft’s own official language server is implemented in TypeScript, meaning integration paths still exist.

---

## Decision Outcome: Transition to TypeScript

After evaluating our experiences with C# and exploring the TypeScript ecosystem, we concluded that a transition from C# to TypeScript is the best path forward for our language server. The decision is largely motivated by the rich ecosystem around the LSP in TypeScript, the clarity of documentation for key libraries like Tree-sitter and YAML, and the direct alignment with Microsoft’s own reference implementations.

In the following paragraphs, we outline the considerations behind this decision and the outcomes we expect.

1. **Tree-sitter Support**  
    With TypeScript, we gain access to actively maintained bindings for Tree-sitter. Publishing and dependency management are straightforward, and the community has validated the reliability of these bindings. This alone saves considerable time that would otherwise be spent wrestling with incomplete C# documentation.

2. **Robust YAML Parsing**  
    Proper YAML parsing is critical for our use case, and libraries like `eemily/yaml` in TypeScript clearly state their resilience against malformed YAML and other tricky edge cases. This level of transparency and reliability reduces our risk of dealing with hidden runtime errors, as we might with less-documented .NET libraries.
	> **[Parsing Documents](https://eemeli.org/yaml/#documents)**  
	> These functions should never throw, provided that `str` is a string and the `options` are valid. Errors and warnings are included in the documents' `errors` and `warnings` arrays. In particular, if `errors` is not empty it's likely that the document's parsed `contents` are not entirely correct.

3. **Language Server Protocol Maturity**  
    Diagnostics, one of the core features in any language server, is more readily available and better supported in TypeScript libraries. Additionally, there is a wider range of supporting libraries and features to handle common language server requirements. While OmniSharp in the .NET world shows promise, key features remain incomplete. Attempting to use diagnostics, results in a `NotImplementedException`. Relying on a more mature, well-documented ecosystem in TypeScript lets us deliver a working solution faster and maintain it more confidently.

4. **Future Integration**  
	 Microsoft’s official language server itself is TypeScript-based. Since a goal is compatibility with modern LSP implementations and potential collaboration with existing technologies, TypeScript remains a viable path for integration. A fiture ADR will address exactly how we intend to integrate the language server with Microsoft's.

---
## Consequences of the Decision

### Positive Consequences

- **Immediate Development Gains**: With well-documented libraries in TypeScript, we can prototype and validate LSP features quickly.
- **Community and Ecosystem**: The TypeScript ecosystem has an active community, frequent updates, and an abundance of examples that reduce our learning curve.
### Negative Consequences
- **Less internal experience**: Developers who are deeply familiar with C# will need time and resources to become proficient in TypeScript.
- **Distance from .NET**: We lose the immediate synergy that comes with staying in the .NET ecosystem, potentially complicating some integration points (although not prohibiting them).

---
## Implementation

The **implementation plan** includes:
1. **Setting Up a TypeScript Project**: Creating a new repository or directory structured around Node.js conventions.
2. **Adopting LSP Tools**: Using Microsoft’s LSP packages for TypeScript and ensuring we can successfully handle features like diagnostics.
3. **Validating Tree-sitter**: Configuring the Tree-sitter bindings to parse the relevant grammars.
4. **Testing YAML Parsing**: Introducing `eemily/yaml`, and ensure we cover malformed input scenarios.
5. **Code Review and Pilot**: Demonstrating the new TypeScript-based language server.

Once we have a functional proof of concept in TypeScript, a design review or code review with the company mentor will confirm that the approach adheres to architectural standards.

---
## References and Links

- **OmniSharp Diagnostics Issue**: [`NotImplementedException` when trying to get document diagnostics · Issue #1250](https://github.com/OmniSharp/csharp-language-server-protocol/issues/1250)
- [Language server protocol implementation for VSCode.](https://github.com/Microsoft/vscode-languageserver-node)
- **Reddit Thread on YAML in .NET**: [dotnet ecosystem is in dire need of a YAML serialize that works correctly](https://www.reddit.com/r/dotnet/comments/152l7gv/dotnet_ecosystem_is_in_dire_need_of_a_yaml/)
- **YamlDotNet Parser documentation:** [Core.Parser · aaubry/YamlDotNet Wiki](https://github.com/aaubry/YamlDotNet/wiki/Core.Parser)
- **Tree-sitter TypeScript Bindings**: [Node.js bindings for tree-sitter](https://github.com/tree-sitter/node-tree-sitter)
- **eemily/yaml Library**: [YAML](https://eemeli.org/yaml/#yaml)